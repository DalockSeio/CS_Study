# 2장 - 컴퓨터 네트워크

## 2.2 TCP와 UDP

### 2.2.1 TCP란? ⭐

TCP란? 연결형 서비스를 지원하고 데이터의 신뢰성을 보장하는 전송계층 네트워크 프로토콜

- 연결 지향적: 송신부와 수신부의 연결을 확인
- 신뢰성 보장
- 패킷 교환 방식: 가상 회선 방식
- 패킷 수신 여부 확인 O, 패킷 순서 보장
- 송신부와 수신부는 1:1통신
- 데이터의 송수신 속도가 느림

#### 패킷 교환 방식

- 가상 회선: 데이터를 주고받기 전에 패킷을 전송할 경로인 가상 회선을 설정해서 모든 패킷을 같은 경로로 전송
- 데이터그램: 패킷마다 최적의 경로로 전송되는 방식

### 2.2.2 TCP 핸드셰이킹 ⭐

송신부와 수신부의 연결 관리

핸드셰이킹 과정에서는 송신부와 수신부 간 연결을 제어 및 관리하도록 플래그(flag)값을 주고 받음

- SYN: Synchronization, 연결 생성
- FIN: Finish, 연결 끊기
- ACK: Acknowledgment, 데이터 전송 시, 수신자가 받았음을 알려줄 때 사용

#### 3-way 핸드셰이킹

TCP 연결 시작, 상대방 컴퓨터와 세션을 수립 (요청과 응답이 총 3번)

1. 송신부 -> 수신부 (송신부 SYN_SENT)
   - SYN(N(임의의 숫자)) 전송

2. 수신부 -> 송신부 (수신부 SYN_RECEIVED)
   - ACK(N + 1) + SYN(M(임의의 숫자)) 전송  

3. 송신부 -> 수신부 (송신부 ESTABLISHED)
   - ACK(M + 1) 전송

연결 완료 (수신부 ESTABLISHED)

#### 4-way 핸드셰이킹

TCP 연결 해제 (요청과 응답이 총 4번)

1. 송신부 -> 수신부 (송신부는 FIN_WAIT1)
    - FIN 전송

2. 수신부 -> 송신부 (수신부는 CLOSE_WAIT)
   - ACK 전송 / 수신부는 연결을 종료하기 위한 작업 실행
   - (송신부는 FIN_WAIT2)

3. 수신부 -> 송신부 (수신부는 LAST WAIT)
   - 연결을 종료할 준비가 끝나면 FIN 전송

4. 송신부 -> 수신부 (송신부는 TIME_WAIT)
    - ACK 전송 / 일정 시간 후에 CLOSED 상태로 전환
    - TIME_WAIT 상태가 필요한 이유: FIN 메시지 전에 보낸 패킷이 지연되어 발생하는 패킷 유실 / ACK 메시지 전달 오류 대비

연결 해제 (수신부 CLOSED)

##### TCP Keep Alive

세션 연결 유지를 원하는 쪽에서 연결 유지 상태 확인을 보내고 응답하여 연결 유지
재요청에 대한 3-way 핸드셰이킹을 줄일 수 있음
FIN 메시지를 받지 못한 경우에 발생 가능한 불필요한 연결(좀비 커넥션) 방지 가능

### 2.2.3 TCP 제어 방법 ⭐

for 신뢰성 보장

데이터 손실 = timeout

#### 흐름 제어

_송신부와 수신부에서 데이터 처리 속도의 차이_ 때문에 발생하는 데이터 손실 방지

1. stop-wait
   - 송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받기 전까지 대기
   - 간단하지만 비효율적

2. sliding window
   - 전송 가능한 패킷 수 = 윈도우 크기 - 아직 수신부로부터 ACK메시지(메시지 전달 확인)가 안 도착한 패킷
   - stop-wait 보완

#### 혼잡 제어

_송신부의 데이터 전달 속도와 네트워크 속도 차이_ 때문에 발생하는 데이터 손실 방지

혼잡이 발생해 네트워크에 패킷이 쌓이면서 일정 시간 응답을 받지 못하면, 송신부에서는 메시지 전송에 실패했다고 판단, 수신부에 패킷을 재전송하며 혼잡 가중화

혼잡 윈도우 크기를 잘 조절하는 것이 관건

1. AIMD
   - 데이터를 전달 시, 합 증가 방식으로 혼잡 윈도우의 크기를 더해가며 키움
   - 데이터 손실 발생 시, 혼잡 윈도우 크기를 곱 감소(Multiplicative Decrease) 방식을 적용해 1/2배와 같은 배수 단위로 줄임
   - 여러 송신부 간에 네트워크 대역폭을 공평하게 사용 가능해짐
   - 데이터 감소폭이 감소폭 대비 크기 때문에 네트워크의 대역폭을 넓게 사용하기까기 오래 걸림

2. 느린 시작
   - 데이터 전달 시, 윈도우 크기를 1부터 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘림
   - 데이터 손실 발생 시, 윈도우 크기를 1로 초기화
   - 패킷 1개 전달 시, ACK 수신이 1번이기에 윈도우 크기는 2, 이후에 패킷 2개 전달 시, ACK 수신이 2번이기에 윈도우 크기는 4가 되며 윈도우 크기가 지수 함수 형태로 증가
   - 초기에 전송 가능한 패킷 수가 적은 AIMD의 단점 보완

3. 혼잡 회피
   - 느린 시작 + 임계점(지수 증가 + 일정 부분부터 선형 증가)
   - 임계점: (timeout 발생 지점) / 2

4. 빠른 회복
   - 데이터 전달 시, 윈도우 크기의 지수 함수 형태 증가 (느린 시작 방식과 유사)
   - 데이터 손실 발생 시, 윈도우 크기를 반으로 초기화 (AIMD의 곱 감소 방식과 유사)

5. 빠른 재전송
    - 데이터 전달 시, 윈도우 크기의 지수 함수 형태 증가 (느린 시작 방식과 유사)
    - 3 Duplicate ACK 발생 시, 윈도우 크기를 반으로 초기화
    - Duplicate ACK란 데이터 손실 발생 혹은 패킷이 순서대로 도착하지 않는 상황일 때 해당 패킷을 전송해달라고 ACK 메시지와 송신자에게 요청하는 것

##### TCP 혼합 제어 정책

혼잡 제어 방식 혼합 version을 많이 사용 (위 3 ~ 5)

ssthresh: 느린시작의 임계점

1. TCP Tahoe
   - ssthresh(지수 증가 + 일정 부분부터 선형 증가): (timeout or 3 Duplicate ACK 발생 지점) / 2

2. TCP Reno
   - ssthresh(지수 증가 + 일정 부분부터 선형 증가)
   - 3 Duplicate ACK
     - ssthresh, 윈도우 크기: (timeout or 3 Duplicate ACK 발생 지점) / 2
   - timeout
     - 윈도우 크기를 1로 초기화

#### 오류 제어

_통신 중 데이터 오류 혹은 유실_ 제어

- 데이터 오류 또는 유실 발생 경우
  - 잘못된 데이터를 받았다는 응답(NAK)
  - 3 Duplicate ACK
  - timeout
  
1. stop-wait
   - 흐름제어 stop-wait 방식
   - timeout 발생 시, 패킷을 다시 보냄
   - ARQ(재전송 요청)

2. Go-Back_N ARQ
   - 수신부에서 정상적으로 받은 패킷 번호 + 1을 해서 ACK를 송신부에 보냄
   - 꼭 모든 ACK(응답 패킷)을 보낼 필요는 없음
   - 만약 지금 까지 보낸 패킷이 ACK의 번호보다 더 많으면 오류로 판단 ACK의 번호부터 재전송
  
3. Selective-Repeat ARQ
   - 송신부에서 연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 수신부에서 해당 데이터만 재전송을 요청
   - 재전송 요청들이 끝나면 지금까지 받은 패킷 번호 + 1을 해서 ACK를 송신부에 보냄
   - 특정 패킷만을 재전송한다는 점은 효율적이나, 받은 패킷을 재정렬하는 로직이 추가로 필요

### 2.2.4 UDP ⭐

UDP란? 송신부와 수신부 간 연결을 지원하지 않고 데이터그램 형태의 통신을 지원하는 전송계층 네트워크 프로토콜
  
- 비연결: 송신부와 수신부의 연결이 보장되지 않음
- 신뢰성 보장 X
- 패킷 교환 방식: 데이터그램
- 패킷 수신 여부 확인 X, 패킷 순서가 다를 수 있음
- 1:1 통신, 1:N 통신, N:N 통신 모두 가능
- 데이터의 전송 속도가 빠름

### 2.2.5 UDP의 오류 검출 ⭐

체크섬 for 최소한의 신뢰성 보장

송신부: 데이터 + 체크섬(보내려는 데이터의 합 -> 캐리 제외한 합 + 캐리 -> 1의 보수)를 보냄

수신부: 체크섬과 보내려는 데이터의 합의 이진수의 비트가 모두 1이어야 함 -> 아니면 오류

체크섬의 신뢰도는 100프로가 아니며, 사용이 선택적이기에 체크섬 값을 0으로 보내면 수신부는 체크섬 계산을 하지 않음
