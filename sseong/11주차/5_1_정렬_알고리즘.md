# 5장 - 알고리즘

## 5.1 정렬 알고리즘

### 5.1.1 버블 정렬

(주어진 배열) 1 4 3 2

1 4 3 2

1 3 4 2

1 3 2 ④

1 3 2 ④

1 2 ③ ④

1 ② ③ ④

n(n - 1) / 2 -> 시간 복잡도 O(n^2) / 메모리 공간 필요로 하지 않아

### 5.1.2 선택 정렬

(주어진 배열) 1 4 3 2
  
① 4 3 2 (n - 1) 연산

① ② 3 4 (n - 2) 연산

① ② ③ 4 (n - 3) 연산

① ② ③ ④

n(n - 1) / 2 -> 시간 복잡도 O(n^2) / 메모리 공간 필요로 하지 않아

### 5.1.3 삽입 정렬

(주어진 배열) 1 4 3 2

① 4 3 2

① ④ 3 2 (n - 3) 연산

① ③ ④ 2 (n - 2) 연산

① ② ③ ④ (n - 1) 연산

n(n - 1) / 2 -> 시간 복잡도 O(n^2) / 메모리 공간 필요로 하지 않아

### 5.1.4 합병 정렬 ⭐

(주어진 배열) 1 4 3 2

(분할)

1 4    3 2

(분할)

1    4    3    2

(합병)

1 4    2 3

(합병)

1 2 3 4

배열 정렬 O(n), 배열 분할 및 합병 O(logn) -> 시간 복잡도 O(nlogn)

### 5.1.5 퀵 정렬 ⭐

(주어진 배열) 5 3 7 6 2 1 8 4

<맨 앞자리 피봇일 경우>   low의 이동방향 ->      high의 이동 방향 <-

5(피봇) 3(low 시작) 7 6 2 1 8 4(high 시작)

5(피봇) 3(low 이동) 7 6 2 1 8 4(high 정지)

5(피봇) 3 7(low 정지) 6 2 1 8 4(high 정지) - > 위치 교환

5(피봇) 3 4 6(low 정지) 2 1 8(high 이동) 7

5(피봇) 3 4 6(low 정지) 2 1(high 정지) 8 7 - > 위치 교환

5(피봇) 3 4 1 2(low 이동)(high 정지) 6 8 7 - > low high 엇갈림

3 4 1 2   5(피봇)   6 8 7 -> 두 부분으로 나뉘어짐

...

시간 복잡도 O(n^2) (피봇을 어느 값으로 선택하느냐에 따하 성능이 좌지우지 되는 편)

### 5.1.6 힙 정렬 ⭐

이진 트리를 이용하여 가장 큰(or 작은) 수를 삭제하는 연산

n개에 수행하기에 O(n), 힙 정렬 알고리즘 O(logn) -> 시간 복잡도 O(nlogn)

### 5.1.7 기수 정렬

(주어진 배열) 11 33 13 39 22 44 26 52

큐 [버킷 1]

11 22 33 44             39

   52 13

-> 11 22 52 33 13 44 39

큐 [버킷 2]

11 22 33 44 52

13    39

-> 11 13 22 33 39 44 52

데이터 개수 n, 최대 자릿 수 d -> 시간 복잡도 O(dn) (빠른 편)

But, 버킷 구성을 위한 추가 메모리 필요, 정렬할 수 있는 데이터 타입이 한정적

### 5.1.8 계수 정렬

(주어진 배열) 5 3 7 6

배열 [0, 0, 0, 1, 0, 1, 1, 1]

-> 3 5 6 7

데이터 개수 n, 데이터의 최댓값 k -> 시간 복잡도 O(n + k)

But, 데이터의 최댓값이 무한대에 수혐하면 시간 복잡도 역시 무한 수렴, 배열을 위한 메모리 공간 필요
