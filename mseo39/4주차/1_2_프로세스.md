## 프로세스

### 1.2.3 프로세스의 생성

fork()함수를 호출해 생성(복사)

![프로세스 생성](image.png)

### 1.2.4 프로세스의 상태도

![프로세스의 상태도](image-1.png)

### 1.2.5 멀티 프로세스와 멑티 스레드

![동시성과 병렬성](image-2.png)

멀티 프로세스 : 응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미

* 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않기 때문에 여러개로 구성하는게 안정적
* 콘텍스트 스위칭 작업이 이루어지는데 시간고 메모라가 필요, 이를 오버헤드라고 불림
* 프로세는 독립적인 메모리를 할당받는데 프로세스 간에 공유할 자원이 있다면 IPC를 통해서 자원을 공유하기 때문에 직접 참조하는 것보다 비효율적이다

멀티 스레드 : 하나의 프로세스에 스레드를 여러개 생성하는 것을 의미

* 스레드 간에 힙, 데이터, 코드 영역을 공유하기 떄문에 콘텍스트 스위칭할 때 오버헤드가 적게 발생하고 IPC를 사용하지 않아도 된다
* 하지만 스택 영역을 다른 스레드와 함께 사용하기 때문에 공유 자원에 대한 동기화가 필수다
* 스레드에 문제가 생기면 다른 스레드에게도 영향을 미칠 수 있다

### 1.2.6 콘텍스트 스위칭
인터럽트: 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것을 의미

* 입출력 발생
* CPU 사용 시간 만료
* 자식 프로세스 생성

-> 인터럽트가 발생하면서 콘텍스트 스위칭이 이루어짐
여기서 콘텍스트는 프로세스의 정보를 의하고 즉, ㅁ널티 프로세스 환경에서 CPU가 처리 중에 프로세스의 정보를 바꾸는 것이 콘텍스트 스위칭이다

-> 콘텍스트 스위칭 과정에서 상태 저장, 상태 로드할 때 CPU는 아무 일도 못한다 이처럼 어떤 처리를 하는 데 간접적인 처리 시간과 메모리가 소요될 경우에 '오버헤드가 발생한다'고 한다

? CPU에서 처리 중인 프로세스가 중간에 변경되어도 이전에실행하던 코드를 이어서 실행 할 수 있는 이유는?

: PCB에 프로그램 카운터와 스택 포인터 값이 저장되어있기 때문

프로그램 카운터: 프로세스가 이어서 처리해야 하는 명령어의 주소 값

스택 포인터: 스택 영역의 데이터가 채워진 가장 높은 주소 값

### 1.2.7 프로세스 동기화

경쟁 상태 : 공유 자원에 동시에 접근해 경쟁하는 상태
-> 의도하지 않은 결과를 초래할 수 있음
-> 이러한 문제를 해결하기 위해서 동기화가 이루어져야함

임계영역 : 공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역을 말한다
-> 데이터의 일관성이 유지되도록 프로세스 동기화 해야한다

임계 영역에 여러 접근이 동시에 발생하는 것을 방지하는 조건

1. 상호배제 기법 : 어떤 프로세스가 실행 중일 때 다른 프로세스가 접근 불가 (1)뮤텍스 (2)세마포어
2. 진행 : 실행 중인 프로세스가 없을 때 프로세스가 실행
3. 한정된 대기 : 무한한 시간을 기다리지 않는다

뮤텍스 : 락을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법
-> 먼저 임계영역에 접근한 프로세스가 락을 걸면 해제하기 전까지 다른 프로세스가 사용 불가능
-> 락킹 메커니즘
-> 락이 풀렸는지 반복문으로 확인
-> 이를 바쁜대기의 한 종류인 스핀락이라고 함

세마포어 : 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법
-> 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서 시그널링 메커니즘이라고 함

### 1.2.8
교착 상태 : 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태

1. 상호배제
2. 점유와 대기
3. 비선점
4. 환형 대기

교착 상태를 막는 법
1. 상호배제 부정
2. 점유와 대기 부정
3. 비선점 부정
4. 환형 대기 부정