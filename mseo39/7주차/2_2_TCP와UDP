### TCP와 UDP
#### 2.2.1 TCP란
* 송신부와 수신부의 연결을 확인하는 연결형 서비스
* 패킷 교환 방식
  * 가상 회선방식: 패킷이 전달되는 회선이 정해져 있는 방식
  * 데이터그램 방식: 최적의 경로로 전송되는 방식, 보낸 패킷과 도착한 패킷의 순서가 다를 수 있다
* 패킷의 수신 여부를 확인
* 송신부와 수신부의 1:1 통신
* 데이터 손실이 없음을 보장하므로 신뢰성이 높다
* 송수신 속도가 느리다

#### 2.2.2 TCP 핸드셰이킹
> 연결을 시작할 때는 3-way 핸드셰이킹을 연결을 종료할 때는 4-way 핸드셰이킹을 한다. 송신부와 수신부 간 연결을 제어 및 관리하도록 flag 값을 주고 받는다. flag 값의 종류는 다음과 같다.

* SYN : 연결을 생성할 때 사용
* FIN : 연결을 끊을 때 사용
* ACK : 승인의 약자로 데이터를 전송하면 수신자가 받았음을 알려줄 때 사용
* RST : 연결을 재설정할 때 사용
* PSH : 빠른 응답이 필요한 데이터를 응용 계층으로 전송할 때 사용
* URG : 다른 데이터가 우선순위가 높은 데이터를 전송할 때 사용

##### 3-way 핸드셰이킹
> 데이터를 본격적으로 주고받기 전에 상대방 컴퓨터와 세션을 수립하는 과정

1. 송신부가 수신부와 연결하기 위해 SYN 메시지를 보내는데, 이때 임의의 숫자 N을 함께 보낸다.
2. 연결 요청을 수락하는 의미인 ACK메시지를 전송한다. 
   ACK 메시지에는 송신부로부터 받은 N에 +1을 한 값을 함께 보낸다. 
   수신부에서도 송신분와의 연결을 확인하기 위해 SYN 메시지에 임의의 숫자인 M을 함께 보낸다
   
3. ACK 메시지와 수신부로부터 받은 M에 +1을 한 값을 함께 보낸다. 이때 송신부에 전송하려는 데이터가 포함될 수 있다.

##### 4-way 핸드셰이킹
> TCP 연결을 해제할 때 이뤄지는 과정이다.

1. 송신부가 수신부와의 연결을 종료하려고 FIN 메시지를 보낸다
2. 수신부가 송신부로부터 FIN 메시지를 받으면 이에 대한 응답으로 ACK 메시지를 보낸다
수신부는 메시지를 보낸 후 앱을 종료하기 위한 작업을 한다
3. 수신부에서 연결을 종료할 준비가 끝나면 송신부에 FIN 메시지를 보낸다
4. 송신부는 서버로부터 받은 FIN 메시지에 응답하기 위해 ACK 메시지를 보낸다
FIN 메시지 전에 보낼 패킷이 FIN 메시지 수신보다 지연되어 발생하는 패킷 유실에 대비한다
또한, 수신부에서 ACK 메시지가 제대로 전달되지 않아 연결해제가 이뤄지지 않는 경우도 대비한다

#### 2.2.3 TCP 제어방법
> TCP의 데이터 신뢰성을 보장하기 위한 제어방법으로 흐름 제어, 혼잡 제어, 오류 제어가 있다.

##### 흐름 제어
> 데이터 송신부와 수신부에서 데이터 처리 속도의 차이 때문에 생기는 데이터 손실을 방지하는 방법

1. 정지-대기
: 송신부에서 데이터를 보낸 후 수신부로부터 ACK 메시지를 받을 때까지 다음 데이터를 보내지 않고 기다리는 방식으로 송신부에서 패킷을 보내고 일정 시간동안 수신부로부터 ACK 메시지를 받지 못하면 패킷을 재전송한다

2. 슬라이딩 윈도우
: 송신부에서 데이터의 수신 여부(ACK)를 확인하지 않고 수신부에서 설정한 윈도운 크기만큼 데이터를 연속적으로 보낼 수 있게 해서 데이터 흐름을 동적으로 제어하는 방식으로 윈도우 크기는 응답받지 않고도 보낼 수 있는 데이터의 최대 개수를 의미
* 윈도우 크기가 4이면 ACK 메시지를 받지 않았어도 4개의 데이터를 보낼 수 있다
* 송신부에서 2개의 데이터를 전송하고 수신부에서 2개의 데이터를 받았다는 ACK 메시지를 보내면 윈도우를 2칸 이동한다

##### 혼잡 제어
> 송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 발생하는 것을 방지하기 위한 방법
혼잡: 네트워크에 패킷 수가 과도하게 증가하는 증상을 의미

1. AIMD
* 데이터를 전달할 때 합 증가 방식으로 혼잡 윈도우의 크기를 더해가면서 키운다
* 데이터 손실이 발생하면 혼잡 윈도우의 크기를 곱 감소 방식을 적용해 1/2배와 같이 배수 단위로 줄인다
* 장점: 시간이 지나면 여러 송신부 간에 네트워크 대역폭을 공평하게 사용
* 단점: 데이터 유실이 발생하면 윈도우 크기 증가폭 대비 윈도우 크기 감소폭이 크기 때문에 네트워크의 대역폭을 넓게 사용하기까지 시간이 오래 걸린다

2. 느린 시작
> 윈도우 크기가 1인 상태에서 시작해 ACK 메시지를 수신할 때마다 윈도우 크기를 1씩 늘려나간다. 그러다 혼잡이 발생하면 윈도우 크기를 1로 확 줄이는 방식으로 보낼 수 있는 패킷 수가 지수 함수 형태로 증가
* AIMD 방식에서 초기에 전송 가능한 패킷 수가 적다는 단점을 보완

3. 혼잡 회피
> 혼잡이 발생하는 것을 방지하기 위해 윈도우 크기에 대한 임계점을 정하는 방식
* 임계점에 도달하면 윈도우 크기를 선형적으로 증가
* 타임아웃이 발생하면 윈도우 크기의 절반을 임계점으로 설정, 윈도우 크기를 초기값으로 변경

4. 빠른 회복
> 혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식

5. 빠른 재전송
> Duplicate ACK가 3번 발생하면 해당 시점의 윈도우 크기를 1/2로 줄인다. Duplicate ACK가 3번 발생하면 혼잡이 발생했다고 판단

6. TCP 혼잡 제어 정책

6-1. TCP Tahoe
* 초반에 느린 시작을 사용해 혼잡 윈도우 크기를 지수적으로 키운다
* ssthresh 값인 4에 도달했을 때, AIMD를 사용해 혼잡 윈도우 크기를 선형적으로 키운다
* Duplicate ACK가 3번 발생하면 혼잡 윈도우 크기를 1로 초기화하고 ssthresh 값을 절반으로 줄인다
* 타임아웃이 발생하면 윈도우 크기를 1로 초기화하고 ssthresh값을 윈도우 크기를 반으로 변경

6-2. TCP Reno
* Duplicate ACK가 3번 발생하면 혼잡 윈도우 크기를 절반으로 줄이고, 줄인 혼잡 윈도우 크기를 ssthresh 값으로 설정한다
* 타임아웃이 발생하면 혼잡 윈도우 크기를 1로 초기화한다. 이때 ssthresh 값은 변경하지 않는다
