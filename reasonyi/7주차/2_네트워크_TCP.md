# 2.1 네트워크 계층

# 2.1.1 OSI 7계층

OSI 7계층(Open Systems Interconnection Reference Model 7 Layers)란 국제 표준화 기구(ISO, International Organization for Standardization)에서 네트워크 통신이 이뤄지는 과정을 7단계로 나눈 네트워크 표준 모델.

**데이터 송수신 흐름**

데이터 송신: 높은 계층 → 낮은 계층

데이터 수신: 낮은 계층 → 높은 계층

- 각 계층은 독립적이다.

### 데이터 캡슐화

데이터를 송신할 때 각 계층에서 필요한 정보를 추가하여 데이터를 가공함.

이때 제어 정보를 담은 헤어(header) 또는 트레일러(trailer)가 붙음.

### 데이터 역캡슐화

수신부에서는 헤더와 트레일러를 분석하여 제거하는 역캡슐화가 진행된다.

## OSI 7계층의 전체 구조 및 역할

7계층 프로토콜: 응용 계층

HTTP, FTP 등의 프로토콜을 응용 프로그램의 UI를 통해 제공

6계층 프로토콜: 표현 계층

데이터를 표준화된 형식으로 변경

5계층 프로토콜: 세션 계층

세션의 유지 및 해제 등 응용 프로그램 간 통신 제어와 동기화를 함

4계층 프로토콜: 전송 계층

신TCP, UDP 같은 전송 방식과 포트 번호 등을 결정

3계층 프로토콜: 네트워크 계층

데이터를 송신부에서 수신부까지 보내기 위한 최적 경로 선택(라우팅, routing) 수행. 

2계층 프로토콜: 데이터 링크 계층

데이터 흐름을 관리하며 데이터의 오류 검출 및 복구 등을 수행

1계층 프로토콜: 물리 계층

데이터를 비트 단위로 변환하여 장비를 사용해 전송

# 2.1.2 TCP/IP 4계층

TCP/IP: 인터넷에서 데이터를 주고받기 위한 네트워크 프로토콜

TCP(Transmission Control Protocol): 패킷(데이터를 나눈 단위)의 전달 여부와 전송 순서를 보장하는 통신 방식

IP(Internet Protocol): 패킷을 빠르게 보내기 위한 통신 방식

TCP/IP 4계층: OSI 7계층을 TCP/IP에 맞춰 단순화 한 것

4계층: 응용 계층

사용자와 소프트웨어를 연결해 주는 계층. HTTP, HTTPS, DNS 등의 프로토콜이 작동

3계층: 전송 계층

데이터의 신뢰성을 보장. 포트 번호로 `세그먼트(데이터의 단위)`를 적절한 응용 프로그램에 전달한다. TCP, UDP 등의 프로토콜이 작동

2계층: 인터넷 계층

데이터를 최종 목적지까지 도달할 수 있게 하는 계층. IP가 대표적인 프로토콜.

전송 계층으로부터 받은 데이터에 헤더를 붙여 캡슐화한다. → 패킷 또는 데이터그램이라고 한다.

1계층: 네트워크 인터페이스 계층

데이터를 전기 신호로 변환하고 MAC 주소를 사용하여 기기에 데이터를 전달한다. Wi-Fi가 대표적인 프로토콜.

# 2.2 TCP와 UDP

# 2.2.1 TCP란

: 전송 계층에 해당하는 네트워크 프로토콜. 연결형 서비스를 지원하고 데이터의 신뢰성을 보장한다.

TCP의 특징

- 송신부와 수신부의 연결을 확인하는 연결형 서비스이다.
- 패킷 교환 방식은 패킷이 전달되는 회선이 정해져 있는 가상 회선 방식이다.
- 패킷의 전송 순서가 보장된다.
- 패킷의 수신 여부를 확인한다.
- 송신부와 수신부는 1:1 통신을 한다.
- 데이터 손실이 없음을 보장하므로 신뢰성이 높다.
- 데이터의 송수신 속도가 느리다.

# 2.2.2 TCP 핸드셰이킹

TCP에서는 연결형 서비스 지원을 위해 송신부와 수신부를 연결하는 과정을 거친다.

연결 시작 시에는 3-way 핸드셰이킹(handshaking), 연결 종료 시에는 4-way 핸드셰이킹을 한다.

핸드셰이킹 과정에서는 송신부와 수신부 간 연결을 제어 및 관리하도록 플래그(flag)값을 주고받는다.

플래그 값 (*SYN, FIN, ACK값을 주로 사용한다.)*

- SYN: Synchronization(동기화)의 약자. 연결을 생성할 때 사용
- FIN: Finish(종료)의 약자. 연결을 끊을 때 사용
- ACK: Acknowledgment(승인)의 약자. 데이터를 전송하면 수신자가 받았음을 알려줄 때 사용
- RST: Reset(초기화)의 약자. 연결을 재설정할 때 사용
- PSH: Push(밀다)의 약자. 빠른 응답이 필요한 데이터를 응용 계층으로 즉시 전송할 때 사용
- URG: Urgent(긴급)의 약자. 다른 데이터보다 우선순위가 높은 데이터를 전송할 때 사용

### 3-way 핸드셰이킹

데이터를 본격적으로 주고받기 전, 상대방 컴퓨터와 세션을 수립하는 과정. 데이터의 정확한 전달을 위해 필요하다.

![image](https://github.com/reasonyi/CS_Study/assets/66377159/4545180e-fcda-4324-a342-ac1de36030ea)


### 4-way 핸드셰이킹

TCP 연결을 해제할 때 이뤄지는 과정이다.

![image](https://github.com/reasonyi/CS_Study/assets/66377159/11c30a16-17f3-4544-9901-758d5fd8e9fb)


# 2.2.3 TCP 제어 방법

- 흐름 제어
    
    : 데이터 송신부에서 데이터 처리 속도의 차이 때문에 생기는 데이터 손실을 방지하는 방법
    
    1. 정지-대기(stop-wait)
        
        : 송신부에서 데이터를 보낸 후 수신부에서 ACK를 받을 때까지 다음 데이터를 보내지 않고 기다리는 방식
        
        만약 일정 시간동안 ACK를 받지 못하면 패킷을 재전송.
        
    2. 슬라이딩 윈도우
        
        : 송신부에서 데이터 수신 여부를 확인하지 않고 수신부에서 설정한 윈도우 크기만큼 데이터를 연속적으로 보내어 데이터 흐름을 동적으로 제어하는 방식
        
        윈도우 크기: 응답받지 않고 보낼 수 있는 데이터의 최대 개수
        
        ACK를 받아야만 다음 메시지르 ㄹ보낼 수 있는 정지-대기 방식의 단점을 보완함
        
- 혼잡 제어
    
    : 송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 발생하는 것을 방지하기 위한 방법
    
    혼잡: 네트워크에 패킷 수가 과도하게 증가하는 증상. 
    
    1. AIMD(AdditiveIncrease Multiplicative Decrease)
        
        데이터 전달 시 합 증가 방식으로 혼잡 윈도우의 크기를 더해가며 키운다. 
        
        데이터 손실이 발생하면 혼잡 윈도우의 크기를 곱 감소(multiplicative decrease) 방식을 적용하여 배수 단위로 줄인다.
        
        - 여러 송신부 간 네트워크 대역폭을 공평하게 사용할 수 있음
        - 데이터 유실 발생 시 윈도우 크기 증가폭 대비 감소폭이 커 대역폭을 넓게 사용하기까지 시간이 오래 걸림
    2. 느린 시작(slow start)
        
        윈도우 크기가 1인 상태로 시작하여 ACK를 메시지 수신 시마다 윈도우 크기를 1씩 늘린다. 
        
        혼잡 발생 시 윈도우 크기를 1로 줄인다.
        
        ex) 처음에 패킷 1개를 보내고 ACK를 받으면 다음에 2개를 보낼 수 있다. 2개를 보내면 ACK를 2개 받기 때문에 다음에 4개를 보낼 수 있다.
        
        - 전송 가능한 패킷 수가 지수 함수 형태로 늘어나기 때문에 AIMD 방식에서 초기 전송 가능 패킷 수가 적다는 단점을 보완한다.
    3. 혼잡 회피(congestion avoidance)
        
        윈도우 크기가 지수 함수 형태로 증가하다 임계점에 다다르면 윈도우 크기를 선형적으로 증가시킨다.
        
        만약 ACK를 받지못해 타임아웃이 발생하면 그 시점에서 윈도우 크기의 절반을 임계점으로 설정하고, 윈도우 크기를 초깃값으로 변경한다.
        
    4. 빠른 회복(fast recovery)
        
        혼잡이 발생하면 혼잡 윈도우 크기를 절반으로 줄인 후 선형적으로 증가하는 방식이다.
        
    5. 빠른 재전송(fast retransmit)
        
        Duplicate ACK가 3번 발생하면 해당 시점의 크기를 1/2로 줄인다. 그 뒤로 ACK를 받으면 다시 윈도우 크기를 키우는 방식.
        
        DUplicate ACK: 패킷이 순서대로 도착하지 않아 받아야 할 차례의 패킷을 ACK메시지와 함께 요청하는것.
        
- 오류 제어
    
    : 통신 중 데이터에 오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식.
    
    데이터 오류 또는 유실 발생을 인지하는 경우
    
    - 수신부에서 잘못된 데이터를 받았다는 응답인 NAK(Negative Acknowledge)메시지를 보낸 경우
    - 3 Duplicate ACK가 발생할 때
    - 수신부로부터 ACK 메시지를 받지 못해 타임아웃이 발생할 때
    
    1. 정지-대기
        
        타임아웃이 발생하면 해당 패킷을 다시 보내는 방식. 흐름 제어에서 나온 정지-대기와 같은 방식.
        
        *이 방식은 송신부에서 데이터를 1개만 보내고 메시지를 기다려야 하므로 ARQ(Automatic Repeat Request, 재전송 요청) 방식이 사용됨*
        
    2. Go-Back-N ARQ
        
        송신부에서 연속적으로 데이터를 보냈을 때, 누락된 데이터가 있다면 해당 데이터부터 재전송하는 방식이다.
        
        수신부에서 마지막으로 받은 패킷+1의 ACK를 보내면 해당 패킷부터 전송한다.
        
        *89p 그림과 함께 이해할 것*
        
    3. Selective-Repeat ARQ
        
        송신부에서 연속적으로 데이터를 보냈을 때 누락된 데이터가 있으면 수신부에서 해당 데이터만 재전송을 요청하는 방식.
        
        - 효율적으로 보이지만 받은 패킷을 재정렬하는 로직이 추가로 필요함
