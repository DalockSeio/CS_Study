# 1.2.9 스레드 안전 
멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러 개가 동시에 접근해도 문제가 없음을 의미한다. 

## 스레드 안전을 위한 조건 
- 상호 배제 :    
 공유 자원에 접근해야 할 때 뮤텍스 또는 세마포어와 같은 상호배제 기법 사용하여 접근 통제

- 원자 연산 :   
 원자 연산은 연산의 유무를 나타내는데, 공유 자원에 접근할 때 원자 연산을 이용하거나 원자적으로 정의된 연산을
이용해 연산 도중에 다른 스레드의 접근을 통제

- 재진입성 :    
 특정 함수를 하나의 스레드에서 실행 중 일때 다른 스레드가 해당 함수를 실행해도 올바른 결과 유도

- 스레드 지역 저장소 :   
 각 스레드에서만 접근할 수 있는 저장소를 사용해서 공유 자원을 줄임

# 1.2.10 IPC 
Inter Process Communication의 약자로, 프로세스 간에 자원을 공유하는 방식이다.

## IPC의 대표적인 종류 
1. 공유 메모리             
   프로세스 간에 공유 메모리를 구성해 자원을 공유하는 방식   
2. 소켓          
   네트워크 소켓을 이용하는 프로세스 간 통신으로, 클라이언트<->서버 구조로 자원을 주고 받는다.  
3. 세마 포어           
   접근하는 프로세스를 제어해 공유 자원 관리   
4. 파이프           
   FIFO 형태의 파이프를 이용해 프로세스 간 자원을 공유하는 방식      
   (파이프는 단방향 통신이므로 양방향 통신을 할 경우엔, 읽기 파이프와 쓰기 파이프를 각각 생성해야 한다.)    
5. 메시지 큐                
   FIFO 형태의 큐 자료구조를 사용해 프로세스 간 메시지를 주고받는 방식

# 1.2.11(1) 좀비 프로세스
자식 프로세스는 종료되었지만, 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않았을 경우에,    
남겨진 자식 프로세스를 일컫는 말이다.    

좀비 프로세스가 쌓이게 된다면 자원이 낭비되기 때문에 방지해야 한다 !     

이럴 때는,
1. 자식 프로세스가 종료될 때 부모 프로세스에 'SIGCHLD' 시그널을 보낸다.
2. 부모 프로세스에서 wait() 함수를 호출한다.
3. 이후에 자식 프로세스의 상태 정보를 받고 자원을 회수하도록 한다.    

# 1.2.11(2) 고아 프로세스
부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우에 자식 프로세스를 일컫는 말이다.    

이럴 때는,    
1. 자식 프로세스의 부모 PID를 init 프로세스의 PID인 1로 바꿔준다.     
2. 이렇게 하면 고아 프로세스의 부모 프로세스는 init 프로세스가 된다.    
3. 이후에 고아 프로세스가 작업을 종료하면 init 프로세스가 고아 프로세스의 자원을 회수한다.

여기서 init 프로세스란?     
부팅 시 가장 먼저 실행되는 프로세스를 말한다. 

# 1.3 스케줄링의 목적 
스케줄링의 주된 목적은 멀티 프로세스 환경에서 모든 프로세스를 공평하게 실행하는 것이다. 

세부적으로는, <공평성, 효율성, 안정성, 반응 시간 보장, 무한 연기 방지> 가 있다. 

# 1.3.2 스케줄링의 단계 
- 장기 스케줄링           
  : 준비 큐에 어떤 프로세스를 넣을지 결정해 메모리에 올라가는 프로세스 수를 조절         
- 중기 스케줄링            
  : 메모리에 로드된 프로세스 수를 동적으로 조절         
  - 스왑 아웃         
    : 메모리에 프로세스가 많이 로드되면 일부 프로세스를 통째로 저장        
  - 스왑 인          
    : 스왑 아웃한 프로세스에서 이벤트 요청이 오면 해당 프로세스를 다시 통째로 메모리에 로드        
- 단기 스케줄링          
  : 준비 큐에 있는 대기 상태 프로세스 중 어떤 프로세스를 실행할지 스케줄링 알고리즘으로 결정

  ![993FEE355BB5F49021](https://github.com/leeshinbi/CS_Study/assets/109641586/6627a327-6493-4864-9745-63017fb1cdfe)



# 1.3.3 스케줄링 알고리즘 
CPU 스케줄러가 준비 큐에 잇는 프로세스 중 어떤 프로세스를 실행할 지 결정하는 데 사용하는 것이다. 

스케줄링 알고리즘은 아래와 같이 두 가지로 나뉜다.    

## 비선점형 알고리즘 
실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음

- FCFS 스케줄링       
  : 준비 큐에 먼저 들어온 프로세스 먼저 실행       
- SJF 스케줄링          
  : 실행 시간이 짧은 프로세스가 높은 우선순위를 획득

## 선점형 알고리즘 
스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음         

- RR 스케줄링          
  : 모든 프로세스를 순서대로 일정 시간 동안 실행하고 일정 시간을 초과하면 다른 프로세스를 실행한다.
  
- SRTF 스케줄링             
  : 준비 큐에서 대기 시간이 가장 짧게 남은 프로세스를 우선 수행하는 알고리즘
  한 프로세스가 실행 중일 때 실행 시간이 더 짧은 프로세스가 준비 큐에 들어오면 그 프로세스가 CPU를 차지한다.
   
- 멀티 레벨 스케줄링            
  : 준비 큐를 목적에 따라 여러 개로 분리해 사용하는 알고리즘
  분리한 큐는 각각 우선순위가 존재하고 각자 다른 스케줄링 알고리즘을 적용할 수 있다.
  - foreground           
    : 성능보다 , 응답 속도가 중요한 프로세스가 들어감         
  - background            
    : 응답 속도보다, 성능이 중요한 프로세스가 들어감 
      
