# 5.1.1 버블 정렬
양옆에 위치한 두 값을 비교하면서 크기 순으로 정렬        
시간 복잡도 = O(n*n)

# 5.1.2 선택 정렬
배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값을 선택해 위치시킨다.         
오름차순 정렬이라면 배열의 첫 번째 자리에는 최솟값을 위치시키고, 두 번째 자리에는 최솟값의 다음 값을 위치시킨다.     
시간 복잡도 = O(n*n)

# 5.1.3 삽입 정렬
배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식        
시간 복잡도 = O(n*n)

# 5.1.4 합병 정렬
재귀를 이용하는 분할 정복 알고리즘으로, 배열을 쪼개면서 정렬하고 다시 하나로 합병하는 방식이다.     
시간 복잡도 = O(nlogN)

# 5.1.5 퀵 정렬
분할 정복 알고리즘 중 하나로, 배열에서 '피봇'이라는 특정 값을 선택해 피봇보다 [작은 값 , 큰 값]으로 구성된 배열로 분할해 정렬하는 방식이다. 
시간 복잡도 = O(nlogN)

# 5.1.6 힙 정렬 
최대 힙이나 최소 힙 자료구조를 이용해 정렬을 수행한다.    
최대 힙으로 오름차순 정렬, 최소 힙으로 내림차순 정렬을 한다.     
시간 복잡도 = O(nlogN)

# 5.1.7 기수 정렬
비교하지 않는 정렬 알고리즘으로, 낮은 자릿수부터 정렬을 수행한다.    
'버킷'이라는 큐를 생성하여 정렬하려는 숫자들의 각 자릿수에 해당하는 숫자를      
각각의 버킷에 넣어 정렬하고 이를 자릿수만큼 반복한다.     
시간 복잡도 = O(dn)

# 5.1.8 계수 정렬
데이터의 개수를 세서 정렬하는 방식이다.    
데이터의 범위를 인덱스로 갖는 빈 배열을 생성하고, 정렬하려는 배열을 순회하면서 데이터에 해당하는 인덱스 값을 1씩 증가한다.    
[조건] 데이터의 범위는 0 또는 양의 정수
