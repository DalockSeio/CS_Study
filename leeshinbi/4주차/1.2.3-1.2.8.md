# 1.2.3 프로세스 생성 
새로운 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성한다.   
fork()함수는 기존 부모 프로세스의 PID 값을 자식 프로세스의 PID 값으로 복사한다.    
또한 자식 프로세스는 0을 반환한다. 

# 1.2.4 프로세스 상태도 
모든 프로세스는 CPU에 의해 생성되고 소멸된다.    
이 과정에서 아래와 같은 상태들을 갖는다. 


![프로세스_상태전이도](https://github.com/leeshinbi/CS_Study/assets/109641586/b4652e86-9880-49eb-8577-89aa12caa812)



- 생성 :  프로세스가 PCB를 갖고 있지만, OS로 부터 승인받기 전 상태
- 준비 : OS로부터 승인받은 후, 준비 큐에서 CPU 할당을 기다리는 상태
- 실행 : 프로세스가 CPU를 할당받고 실행하는 상태
- 대기 : 프로세스가 입출력 및 이벤트 발생을 기다리고 있어서 CPU 사용을 잠시 멈추고 기다리는 상태
- 종료 : 프로세스 실행을 종료한 상태 


# 1.2.5 멀티 프로세스와 멀티 스레드 
먼저 알아야 할 개념 두가지가 있다!    

1. 동시성
   : 하나의 코어에서 여러 작업을 번갈아 가면서 처리하는 방식
   하나의 CPU에서 여러 작업을 번갈아 가면서 처리하기 위해 처리 중인 작업을
   교체하는 것을 "콘텍스트 스위칭" 이라고 한다

2. 병렬성
   : CPU가 여러 개의 코어가 있어서, 각 CPU에서 각 작업을 동시에 처리하는 방식

## 멀티 프로세스 
응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미한다. 
이 환경에서는 한 프로세스가 죽어도 다른 프로세스 영향을 주지 않기에 안정적이다. 
          
BUT, 단점은 시간과 메모리 공간을 많이 사용한다는 점이다.     
CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을    
다른 프로세스에서 사용할 수 있게 교체하면서 시간과 메모리가 필요한데 , 이것을 '오버헤드' 라고 한다. 
   
또한, 프로세스는 공유할 자원이 있다면, IPC(Inter Process Communication)를 통해 프로세스 간에 자원을 공유한다. 

## 멀티 스레드 
스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미한다.      
스레드 간에 힙, 데이터, 코드 영역을 공유하기 때문에      
콘텍스트 스위칭을 할 때, 오버헤드는 줄고 IPC는 사용하지 않아도 되어 멀티 프로세스의 단점을 보완한다. 

BUT, 주의할 점은 스택 영역을 다른 스레드와 함께 사용하므로 공유 자원에 대한 '동기화'가 필수다. 
또한, 스레드에 문제가 생기면, 프로세스 내 다른 스레드에 영향을 미칠 수 있다. 

# 1.2.6 콘텍스트 스위칭 
멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것을 의미한다. 

CPU는 하나의 프로세스만 처리할 수 있으므로, 멀티 프로세스를 처리하려면 CPU 스케줄러에 의해    
인터럽트가 발생하면서 콘텍스트 스위칭이 이뤄진다 .

여기서 인터럽트란?     
CPU에서 프로세스를 처리하다가, 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것이다. 

그럼 콘텍스트란?    
CPU가 처리하는 프로세스의 정보를 의미한다. 

콘텍스트 스위칭 과정을 그림으로 나타내면 아래와 같다. 
![img](https://github.com/leeshinbi/CS_Study/assets/109641586/753dbb4e-808a-4563-91ec-2ecc45cfbe93)

❔ 여기서, CPU가 처리 중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유?    
❗ PCB에 프로그램 카운터와 스택 프인터 값이 저장되어 있기 때문이다! 

# 1.2.7 프로세스 동기화 
동기화를 알려면, 일단 아래의 개념에 대해 이해를 해야한다. 

## 경쟁 상태 
여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 상태를 말한다. 

아래는 이해를 돕기 위한 그림이다.    
![033](https://github.com/leeshinbi/CS_Study/assets/109641586/777635ed-c1f2-4e87-9fd8-2ee630933070)

각각의 프로세스가 하나의 자원을 가져오므로써, 의도하지 않게 자원이 2개가 생성되어 버린다.     
이러한 경우를 대비해 '프로세스 동기화' 가 이뤄져야 한다

## 임계 영역
공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역을 말한다. 

임계 영역에 여러 접근이 동시에 발생하는 것을 방지하려면 아래 3가지 조건을 충족해야 한다.      


✔️ 상호 배제 기법   
      : 어떤 프로세스가 임계 영역을 실행 중이면, 다른 프로세스가 그 임계 영역에 접근 불가 ! 
      (EX. 뮤텍스, 세마포어)
      
✔️ 진행   
      : 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행한다 
      
✔️ 한정된 대기    
      : 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않는다


## 뮤텍스 
락(LOCK)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법 !     

임계 영역에 먼저 접근한 프로세스가 임계 영역에 락을 걸면,    
다른 프로세스들은 해당 프로세스가 락을 해제하기 전까지 대기한다. 

여기서 기다리는 프로세스는 락이 풀렸는지 반복문을 도는데, 이 과정을 '스핀락' 이라고 한다. 

## 세마포어 
공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법 !    

임계 영역에 접근할 수 있는 키 N개를 지정 후 ,    
이 중 하나를 가진 프로세스만이 임계 영역에 접근하게 하는 방식이다. 

접근을 해제한 프로세스는 다른 프로세스에게 접근 신호를 보내는데, 이 과정을 '시그널링 메커니즘'이라고 한다. 

# 1.2.8 교착 상태 
앞서 설명한 '상호 배제' 기법으로 인해, 2개 이상의 프로세스가 각각 자원을 가지고 있으면서    
서로의 자원을 요구하며 기다리는 상태를 말한다. 

교착 상태를 방지하려면, 네 가지 필수 조건 중 하나 이상을 부정하면 된다. 

✔️ 상호 배제(Mutual Exclusion) 부정    
읽기 전용 파일과 같은 공유 자원을 사용합니다.    

✔️ 점유 및 대기(Hold and Wait) 부정    
프로세스 대기를 없애기 위해서 프로세스가 실행되기 전에 필요한 모든 자원을 할당합니다. (자원 낭비 발생)    
자원을 점유하지 않고 있을 때에만 다른 자원을 요청할 수 있도록 합니다. (기아상태가 될 수 있음)     

✔️ 비선점(No Preemption) 부정    
모든 자원에 대한 선점을 허용합니다.    
프로세스가 할당받을 수 없는 자원을 요청하는 경우, 기존에 가지고 있던 자원을 모두 반납하고 새 자원과 이전 자원을 얻기 위해 대기하도록 합니다. (자원 낭비 발생 )

✔️ 순환 대기(Circular Wait) 부정     
자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 합니다. (자원 낭비 발생)

