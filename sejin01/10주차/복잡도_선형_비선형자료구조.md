# 4.1.1
## 복잡도와 빅오 표기법
시간 복잡도 : 알고리즘의 실행 시간을 정량화하는 것
공간 복잡도 : 실행하는 데 필요한 메모리 사용량을 정량화하는 것
빅오 표기법 : 입력 값(n)에 대한 수식에서 최고차항을 기준으로 알고리즘이 수행되는 최악의 시간 복잡도를 표현함



# 4.2 선형 자료구조
# 4.2.1
## 배열
정해진 크기만큼 데이터가 일렬로 저장되는 정적 자료구조
데이터 - 요소 / 데이터를 가리키는 번호 - 인덱스

# 4.2.2
## 연결리스트
크기가 정해져 있지 않은 동적 자료구조. 여러 개의 노드로 구성되어 있음
노드 : 데이터와 다음 노드가 저장된 주소 값을 가지고 있음

# 4.2.3
## 스택
데이터를 쌓는 형태. LIFO(후입선출)형태의 자료 구조
데이터 삽입 연산 - push / 데이터 삭제 연산 - pop / 데이터 확인 연산 - peek
스택이 비어 있는 지 확인 - isEmpty / 스택이 가득 찼는 지 확인 - isFull

# 4.2.4
## 큐
데이터가 순차적으로 들어오는 형태. FIFO(선입선출) 형태의 자료구조
큐의 맨 앞 - front / 맨 뒤 - rear
큐의 맨 뒤에 데이터 삽입 - 인큐(enqueue) / 큐의 맨 앞에서 삭제 - 다큐(dequeue)
peek, isEmpty, isFull (스택과 동일)

## 덱
양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능한 자료구조로, 큐와 스택을 합친 형태



# 4.3 비선형 자료구조
# 4.3.1 
## 그래프
데이터를 포함하는 정점, 정점을 잇는 간선으로 구성된 자료구조
무방향 그래프 / 방향 그래프 / 가중치 그래프 등등

## 경로 탐색
- 너비 우선 탐색(BFS)
탐색을 시작하는 정점에서 가까운 정점을 먼저 탐색하는 방식
- 깊이 우선 탐색(DFS)
시작 정점에서 탐색 가능한 최대 깊이의 정점까지 탐색
재귀 호출 OR 스택으로 구현 가능

# 4.3.2 
## 트리
그래프의 한 종류로 사이클이 없어서 계층적 관계를 표현할 수 있음
루트 노드(root node): 부모 노드가 없는 노드. 트리에는 하나만 존재
부모 노드(parent node): 루트 노드 방향으로 연결됨 
자식 노드(child node): 루트 노드의 반대 방향으로 연결됨 
단말 노드(leaf node): 자식 노드가 없음 
형제 노드(sibling node): 부모 노드가 같음
레벨(level): 루트 노드로부터 노드의 상대적 위치를 의미함. 일반적으로 루트 노드의 레벨은 0.
높이 (height): 트리의 최대 레벨 +1
차수(degree): 자식 노드의 개수

## 이진 트리
자식 노드가 최대 2개인 트리
- 완전 이진 트리(complete binary tree)
- 포화 이진 트리 (perfect binary tree)
마지막 레벨까지 노드가 모두 채워져 있음
- 이진 탐색 트리 (BST， Binary Search Tree)
왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 가진 노드로 구성, 오른쪽 서브트리는 해당 노드의 값보다 큰 값을 가진 노드로 구성.

# 4.3.3
## 우선순위 큐
우선순위가 높은 데이터가 먼저 나오는 자료구조

# 4.3.4
## 힙
완전 이진 트리로 최댓값 또는 최솟값을 빠르게 찾을 수 있는 자료구조
삽입 연산 / 삭제 연산

# 4.3.5
## 해시 테이블
하나의 키에 대해 하나의 값을 저장하는 형태의 자료구조
키 - 해시 함수를 사용해 해시를 얻음 / 해시 : 값이 저장되어 있는 해시 테이블의 인덱스를 찾을 수 있는 값
단점) 해시 충돌 - 서로 다른 키에 대해 같은 해시가 도출되는 것

## 해시 충돌 해결 방법
- 체이닝
같은 해시가 나오는 키의 값을 연결 리스트에 저장하는 방식
- 개방 주소법
해당 해시가 아닌 비어 있는 공간에 값을 저장한느 방식
선형 주사법, 이차 조사법, 이중 해싱이 있음